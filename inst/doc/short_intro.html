<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Darjus Hosszejni and Sylvia Frühwirth-Schnatter" />


<title>The 3579 Counting Rule in Sparse Factor Analysis</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">The 3579 Counting Rule in Sparse Factor Analysis</h1>
<h4 class="author">Darjus Hosszejni and Sylvia Frühwirth-Schnatter</h4>
<h4 class="date">February 2023</h4>



<p>This is a short introduction to the <code>sparvaride</code> package. The package implements the variance identification algorithm for sparse factor analysis described in the paper “Cover It Up! Bipartite Graphs Uncover Identifiability in Sparse Factor Analysis” by Darjus Hosszejni and Sylvia Frühwirth-Schnatter. The paper is available at <a href="https://arxiv.org/abs/2211.00671">arXiv</a>.</p>
<p>The package is still under development and the API is subject to change.</p>
<div id="problem-statement" class="section level2">
<h2>Problem Statement</h2>
<p>At the moment, the package has a single exported function called <code>counting_rule_holds</code> with one input variable: a binary matrix <span class="math inline">\(\delta\in\{0,1\}^{m\times r}\)</span>. This binary matrix <span class="math inline">\(\delta\)</span> should be the sparsity pattern of the factor loading matrix <span class="math inline">\(\beta\in\mathbb{R}^{m\times r}\)</span> in sparse factor analysis: <span class="math display">\[y_i = \beta f_i + \epsilon_i,\]</span> where <span class="math inline">\(y_i\in\mathbb{R}^m\)</span> is the <span class="math inline">\(i\)</span>th vector of observations, <span class="math inline">\(f_i\in\mathbb{R}^r\)</span> is the <span class="math inline">\(i\)</span>th vector of latent factors, <span class="math inline">\(\epsilon_i\in\mathbb{R}^m\)</span> is the <span class="math inline">\(i\)</span>th vector of idiosyncratic errors, and <span class="math inline">\(i=1,...,n\)</span>. In sparse factor analysis, the factor loading matrix <span class="math inline">\(\beta\)</span> may be sparse, i.e., <span class="math inline">\(\beta\)</span> may only have a small number of non-zero entries. Importantly, <span class="math inline">\(\beta\)</span> may have (estimated) structural zeros, and the sparsity pattern is <span class="math inline">\(\delta=I(\beta \neq 0)\)</span>, where <span class="math inline">\(I()\)</span> is the indicator function. For mathematical tractability, we assume orthogonal factors, i.e., <span class="math inline">\(\text{cov}(f_i)=I_r\)</span> identity, and homoskedasticity for the observation series, i.e., <span class="math inline">\(\text{cov}(\epsilon_i)\)</span> is diagonal.</p>
<p>In this setup, the covariance matrix <span class="math inline">\(\text{cov}(\epsilon_i)\)</span> of the idiosyncratic errors may not be uniquely identified if there are too many zeros in <span class="math inline">\(\beta\)</span> (and thus in <span class="math inline">\(\delta\)</span>). The 3579 counting rule is a sufficient condition for the uniqueness of the covariance matrix <span class="math inline">\(\text{cov}(\epsilon_i)\)</span>. More information on the 3579 counting rule can be found in the paper “Cover It Up! Bipartite Graphs Uncover Identifiability in Sparse Factor Analysis” by Darjus Hosszejni and Sylvia Frühwirth-Schnatter at <a href="https://arxiv.org/abs/2211.00671">https://arxiv.org/abs/2211.00671</a>.</p>
</div>
<div id="the-3579-counting-rule" class="section level2">
<h2>The 3579 Counting Rule</h2>
<p><strong>Def.</strong> Let <span class="math inline">\(\delta\in\{0,1\}^{m\times r}\)</span> be a binary matrix. Then, the 3579 counting rule is the following condition: for all <span class="math inline">\(q=1,...,r\)</span>, all submatrices of <span class="math inline">\(\delta\)</span> consisting of <span class="math inline">\(q\)</span> columns of <span class="math inline">\(\delta\)</span> have at least <span class="math inline">\(2q+1\)</span> non-zero entries.</p>
<p>For example, for <span class="math inline">\(\delta_1\)</span> below the counting rule does not hold because there is a <span class="math inline">\(q\)</span> (namely, <span class="math inline">\(q=1\)</span>), such that there is a submatrix of <span class="math inline">\(\delta_1\)</span> consisting of <span class="math inline">\(1\)</span> column of <span class="math inline">\(\delta_1\)</span> that has only <span class="math inline">\(2q=2\)</span> non-zero entries: the middle column. For <span class="math inline">\(\delta_2\)</span>, however, the counting rule holds because there is no <span class="math inline">\(q\)</span> such that there is a submatrix of <span class="math inline">\(\delta_2\)</span> consisting of <span class="math inline">\(q\)</span> columns of <span class="math inline">\(\delta_2\)</span> that has only <span class="math inline">\(2q\)</span> non-zero entries.</p>
<p><span class="math display">\[\delta_1=\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1
\end{pmatrix}, \quad\quad\quad \delta_2=\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1
\end{pmatrix}\]</span></p>
</div>
<div id="the-counting_rule_holds-function" class="section level2">
<h2>The <code>counting_rule_holds</code> Function</h2>
<p>We can check whether the 3579 counting rule holds for a given binary matrix <code>delta</code> using the <code>counting_rule_holds</code> function in the <code>sparvaride</code> package.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(sparvaride)</a></code></pre></div>
<p>We define two matrices as above in R:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">delta1 &lt;-</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">  </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb2-3" title="3">           <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb2-4" title="4">           <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-5" title="5">           <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-6" title="6">           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-7" title="7">           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-8" title="8">           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb2-9" title="9">         <span class="dt">nrow =</span> <span class="dv">7</span>, <span class="dt">ncol =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb2-10" title="10">         <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb2-11" title="11">delta2 &lt;-</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="st">  </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb2-13" title="13">           <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb2-14" title="14">           <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-15" title="15">           <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-16" title="16">           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-17" title="17">           <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb2-18" title="18">           <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb2-19" title="19">         <span class="dt">nrow =</span> <span class="dv">7</span>, <span class="dt">ncol =</span> <span class="dv">3</span>,</a>
<a class="sourceLine" id="cb2-20" title="20">         <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>Then, we call the <code>counting_rule_holds</code> function on these matrices:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">counting_rule_holds</span>(delta1)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">#&gt; [1] FALSE</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">counting_rule_holds</span>(delta2)</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
<div id="citation" class="section level2">
<h2>Citation</h2>
<p>For citing our work, please check the <code>citation</code> function in R:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">citation</span>(<span class="st">&quot;sparvaride&quot;</span>)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">#&gt; To cite sparvaride in publications use:</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">#&gt;   Hosszejni D, Frühwirth-Schnatter S (2022). &quot;Cover It Up! Bipartite</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">#&gt;   Graphs Uncover Identifiability in Sparse Factor Analysis.&quot;</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">#&gt;   doi:10.48550/arXiv.2211.00671</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">#&gt;   &lt;https://doi.org/10.48550/arXiv.2211.00671&gt;, arXiv: 2211.00671.</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">#&gt; A BibTeX entry for LaTeX users is</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">#&gt;   @Unpublished{,</span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co">#&gt;     title = {Cover It Up! Bipartite Graphs Uncover Identifiability in Sparse Factor Analysis},</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">#&gt;     author = {Darjus Hosszejni and Sylvia Frühwirth-Schnatter},</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">#&gt;     year = {2022},</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">#&gt;     note = {arXiv: 2211.00671},</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co">#&gt;     doi = {10.48550/arXiv.2211.00671},</span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co">#&gt;   }</span></a></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
